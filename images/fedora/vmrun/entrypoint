#!/bin/bash

set -e

#
# For debug-mode, pass as arguments to this script:
#
#     systemd.wants=serial-getty@<TTY> systemd.mask=cherryimages
#
# This will mask the vm-service, and instead request a getty on on the serial
# line connected to the kernel console.
#

# figure out some arch-specific parameters
case "$FEDORA_ARCH_TARGET" in
armv7hl)
        SERIAL="ttyAMA0"
        QEMU_MACHINE="-M virt -cpu cortex-a15"
        ;;
*)
        SERIAL="ttyS0"
        QEMU_MACHINE="" # use default
        ;;
esac

# Compose qemu cmdline
if [[ -z $QEMU_CMDLINE ]] ; then
        QEMU_CMDLINE=""

        # setup interactive lines
        QEMU_CMDLINE+=" -nographic -vga none"
        QEMU_CMDLINE+=" -monitor none -serial stdio"

        # setup machine
        QEMU_CMDLINE+=" -m 2G ${QEMU_MACHINE}"
        QEMU_CMDLINE+=" -device virtio-rng-pci"

        # pass kernel+initrd
        QEMU_CMDLINE+=" -kernel /mnt/cherryimages/stage-${FEDORA_ARCH_TARGET}/linux"
        QEMU_CMDLINE+=" -initrd /mnt/cherryimages/stage-${FEDORA_ARCH_TARGET}/initrd"

        # pass volumes
        QEMU_CMDLINE+=" -drive id=hd0,if=none,format=qcow2,file=/mnt/cherryimages/stage-${FEDORA_ARCH_TARGET}/runtime.qcow2"
        QEMU_CMDLINE+=" -device virtio-blk-pci,drive=hd0"
        QEMU_CMDLINE+=" -drive id=hd1,if=none,readonly,format=raw,file=fat:16:/mnt/cherryimages/input"
        QEMU_CMDLINE+=" -device virtio-blk-pci,drive=hd1"

        # setup communication line
        QEMU_CMDLINE+=" -serial file:/mnt/cherryimages/output"

        # use kvm if accessible and mapped
        if [[ -r "/dev/kvm" && -w "/dev/kvm" ]] ; then
                QEMU_CMDLINE+=" -enable-kvm"
        fi
fi

# Compose kernel cmdline
if [[ -z $KERNEL_CMDLINE ]] ; then
        KERNEL_CMDLINE=""

        # forward all journal contents to the console
        KERNEL_CMDLINE+="    systemd.journald.forward_to_console=yes"
        KERNEL_CMDLINE+=" rd.systemd.journald.forward_to_console=yes"

        # disable dynamic progress output on the console
        KERNEL_CMDLINE+="    systemd.show_status=no"
        KERNEL_CMDLINE+=" rd.systemd.show_status=no"

        # mount root FS writable
        KERNEL_CMDLINE+=" rw root=/dev/vda"

        # disable security for now
        KERNEL_CMDLINE+=" selinux=0 audit=0"
        KERNEL_CMDLINE+=" console=${SERIAL}"

        # append commandline
        KERNEL_CMDLINE+=" $@"
fi

# clear output file
rm -f -- "/mnt/cherryimages/output"

# create COW overlay, unless it already exists
if [[ ! -f "/mnt/cherryimages/stage-${FEDORA_ARCH_TARGET}/runtime.qcow2" ]] ; then
        qemu-img \
                create \
                -f qcow2 \
                -b image.qcow2 \
                -F qcow2 \
                "/mnt/cherryimages/stage-${FEDORA_ARCH_TARGET}/runtime.qcow2"
fi

# run machine
"qemu-system-${QEMU_BIN_ARCH}" \
        -append "${KERNEL_CMDLINE}" \
        ${QEMU_CMDLINE}

# verify machine executed successfully
[[ $(cat "/mnt/cherryimages/output") = "success" ]] || exit 1

#
# We explicitly leave the QCOW2 overlay, as well as the output from ttyS1
# untouched. Thus, they can be expected for debugging purposes afterwards. If
# the image is meant to be re-used, just create a new throw-away container.
#
