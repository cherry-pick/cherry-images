#!/bin/bash

set -e

# select target if none pre-selected
TARGET_UNIT=${TARGET_UNIT-"cherryimages.service"}

# figure out some arch-specific parameters
case "$FEDORA_ARCH_TARGET" in
armv7hl)
        QEMU_MACHINE="-M virt -cpu cortex-a15"
        ;;
*)
        QEMU_MACHINE="" # use default
        ;;
esac

# Compose qemu cmdline
if [[ -z $QEMU_CMDLINE ]] ; then
        QEMU_CMDLINE="${QEMU_CMDLINE_PRE}"

        # clear defaults
        QEMU_CMDLINE+=" -nodefaults -nographic"

        # setup machine
        QEMU_CMDLINE+=" -m 2G ${QEMU_MACHINE}"
        QEMU_CMDLINE+=" -device virtio-rng-pci"
        QEMU_CMDLINE+=" -net nic -net user"

        # setup serial lines
        QEMU_CMDLINE+=" -serial stdio"
        QEMU_CMDLINE+=" -chardev file,id=serial1,path=/var/lib/cherryimages/output"
        QEMU_CMDLINE+=" -device virtio-serial"
        QEMU_CMDLINE+=" -device virtserialport,chardev=serial1,name=cherryimages.output"

        # pass kernel+initrd
        QEMU_CMDLINE+=" -kernel /var/lib/cherryimages/stage-${FEDORA_ARCH_TARGET}/linux"
        QEMU_CMDLINE+=" -initrd /var/lib/cherryimages/stage-${FEDORA_ARCH_TARGET}/initrd"

        # pass volumes
        QEMU_CMDLINE+=" -drive id=hd0,if=none,format=qcow2,file=/var/lib/cherryimages/stage-${FEDORA_ARCH_TARGET}/runtime.qcow2"
        QEMU_CMDLINE+=" -device virtio-blk-pci,drive=hd0"
        QEMU_CMDLINE+=" -drive id=hd1,if=none,readonly,format=raw,file=fat:16:/var/lib/cherryimages/bin"
        QEMU_CMDLINE+=" -device virtio-blk-pci,drive=hd1"
        QEMU_CMDLINE+=" -fsdev local,id=hd2,readonly,security_model=none,path=/var/lib/cherryimages/src"
        QEMU_CMDLINE+=" -device virtio-9p-pci,fsdev=hd2,mount_tag=cherryimages-src"

        # use kvm if accessible and mapped
        if [[ -r "/dev/kvm" && -w "/dev/kvm" ]] ; then
                QEMU_CMDLINE+=" -enable-kvm"
        fi

        QEMU_CMDLINE+=" ${QEMU_CMDLINE_POST}"
fi

# Compose kernel cmdline
if [[ -z $KERNEL_CMDLINE ]] ; then
        KERNEL_CMDLINE="${KERNEL_CMDLINE_PRE}"

        # forward all journal contents to the console
        KERNEL_CMDLINE+="    systemd.journald.forward_to_console=yes"
        KERNEL_CMDLINE+=" rd.systemd.journald.forward_to_console=yes"

        # disable dynamic progress output on the console
        KERNEL_CMDLINE+="    systemd.show_status=no"
        KERNEL_CMDLINE+=" rd.systemd.show_status=no"

        # mount root FS writable
        KERNEL_CMDLINE+=" rw root=/dev/vda"

        # disable security for now
        KERNEL_CMDLINE+=" selinux=0 audit=0"
        KERNEL_CMDLINE+=" console=${QEMU_TTY_PREFIX}0"

        # pull in cherryimages.service
        KERNEL_CMDLINE+=" systemd.wants=${TARGET_UNIT}"

        KERNEL_CMDLINE+=" ${KERNEL_CMDLINE_POST}"
fi

# clear output file
rm -f -- "/var/lib/cherryimages/output"

# create COW overlay, unless it already exists
if [[ ! -f "/var/lib/cherryimages/stage-${FEDORA_ARCH_TARGET}/runtime.qcow2" ]] ; then
        qemu-img \
                create \
                -f qcow2 \
                -b image.qcow2 \
                -F qcow2 \
                "/var/lib/cherryimages/stage-${FEDORA_ARCH_TARGET}/runtime.qcow2"
fi

# preserve environment
printf "%s\n" "${CHERRY_ENV}" >"/var/lib/cherryimages/bin/env"

# create runner
cat >"/var/lib/cherryimages/bin/main" <<EOF
#!/bin/bash
set -e
export CHERRY_ENV="$(cat /var/lib/cherryimages/bin/env)"
exec ${@@Q}
EOF

# run machine
"qemu-system-${QEMU_BIN_ARCH}" \
        -append "${KERNEL_CMDLINE}" \
        ${QEMU_CMDLINE}

# verify machine executed successfully
[[ $(cat "/var/lib/cherryimages/output") = "success" ]] || exit 1

#
# We explicitly leave the QCOW2 overlay, as well as the output from ttyS1
# untouched. Thus, they can be expected for debugging purposes afterwards. If
# the image is meant to be re-used, just create a new throw-away container.
#
